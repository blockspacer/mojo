// Copyright Â© 2017 by Donald King <chronos@chronos-tachyon.net>
// Available under the MIT License. See LICENSE for details.

#include <string>
#include <vector>

#include "crypto/cipher/rc4.h"
#include "crypto/crypto.h"
#include "encoding/hex.h"
#include "gtest/gtest.h"

TEST(RC4, Encrypt) {
  struct TestRow {
    std::vector<uint8_t> key;
    std::vector<uint8_t> keystream;
  };
  std::vector<TestRow> testdata = {
      {{0x01U, 0x23U, 0x45U, 0x67U, 0x89U, 0xabU, 0xcdU, 0xefU},
       {0x74U, 0x94U, 0xc2U, 0xe7U, 0x10U, 0x4bU, 0x08U, 0x79U}},
      {{0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U},
       {0xdeU, 0x18U, 0x89U, 0x41U, 0xa3U, 0x37U, 0x5dU, 0x3aU}},
      {{0xefU, 0x01U, 0x23U, 0x45U},
       {0xd6U, 0xa1U, 0x41U, 0xa7U, 0xecU, 0x3cU, 0x38U, 0xdfU, 0xbdU, 0x61U}},
      {{0x4bU, 0x65U, 0x79U},
       {0xebU, 0x9fU, 0x77U, 0x81U, 0xb7U, 0x34U, 0xcaU, 0x72U, 0xa7U, 0x19U}},
      {{0x57U, 0x69U, 0x6bU, 0x69U},
       {0x60U, 0x44U, 0xdbU, 0x6dU, 0x41U, 0xb7U}},
      {{0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U},
       {0xdeU, 0x18U, 0x89U, 0x41U, 0xa3U, 0x37U, 0x5dU, 0x3aU, 0x8aU, 0x06U,
        0x1eU, 0x67U, 0x57U, 0x6eU, 0x92U, 0x6dU, 0xc7U, 0x1aU, 0x7fU, 0xa3U,
        0xf0U, 0xccU, 0xebU, 0x97U, 0x45U, 0x2bU, 0x4dU, 0x32U, 0x27U, 0x96U,
        0x5fU, 0x9eU, 0xa8U, 0xccU, 0x75U, 0x07U, 0x6dU, 0x9fU, 0xb9U, 0xc5U,
        0x41U, 0x7aU, 0xa5U, 0xcbU, 0x30U, 0xfcU, 0x22U, 0x19U, 0x8bU, 0x34U,
        0x98U, 0x2dU, 0xbbU, 0x62U, 0x9eU, 0xc0U, 0x4bU, 0x4fU, 0x8bU, 0x05U,
        0xa0U, 0x71U, 0x08U, 0x50U, 0x92U, 0xa0U, 0xc3U, 0x58U, 0x4aU, 0x48U,
        0xe4U, 0xa3U, 0x0aU, 0x39U, 0x7bU, 0x8aU, 0xcdU, 0x1dU, 0x00U, 0x9eU,
        0xc8U, 0x7dU, 0x68U, 0x11U, 0xf2U, 0x2cU, 0xf4U, 0x9cU, 0xa3U, 0xe5U,
        0x93U, 0x54U, 0xb9U, 0x45U, 0x15U, 0x35U, 0xa2U, 0x18U, 0x7aU, 0x86U,
        0x42U, 0x6cU, 0xcaU, 0x7dU, 0x5eU, 0x82U, 0x3eU, 0xbaU, 0x00U, 0x44U,
        0x12U, 0x67U, 0x12U, 0x57U, 0xb8U, 0xd8U, 0x60U, 0xaeU, 0x4cU, 0xbdU,
        0x4cU, 0x49U, 0x06U, 0xbbU, 0xc5U, 0x35U, 0xefU, 0xe1U, 0x58U, 0x7fU,
        0x08U, 0xdbU, 0x33U, 0x95U, 0x5cU, 0xdbU, 0xcbU, 0xadU, 0x9bU, 0x10U,
        0xf5U, 0x3fU, 0xc4U, 0xe5U, 0x2cU, 0x59U, 0x15U, 0x65U, 0x51U, 0x84U,
        0x87U, 0xfeU, 0x08U, 0x4dU, 0x0eU, 0x3fU, 0x03U, 0xdeU, 0xbcU, 0xc9U,
        0xdaU, 0x1cU, 0xe9U, 0x0dU, 0x08U, 0x5cU, 0x2dU, 0x8aU, 0x19U, 0xd8U,
        0x37U, 0x30U, 0x86U, 0x16U, 0x36U, 0x92U, 0x14U, 0x2bU, 0xd8U, 0xfcU,
        0x5dU, 0x7aU, 0x73U, 0x49U, 0x6aU, 0x8eU, 0x59U, 0xeeU, 0x7eU, 0xcfU,
        0x6bU, 0x94U, 0x06U, 0x63U, 0xf4U, 0xa6U, 0xbeU, 0xe6U, 0x5bU, 0xd2U,
        0xc8U, 0x5cU, 0x46U, 0x98U, 0x6cU, 0x1bU, 0xefU, 0x34U, 0x90U, 0xd3U,
        0x7bU, 0x38U, 0xdaU, 0x85U, 0xd3U, 0x2eU, 0x97U, 0x39U, 0xcbU, 0x23U,
        0x4aU, 0x2bU, 0xe7U, 0x40U}},
  };

  for (const auto& row : testdata) {
    auto crypter = crypto::cipher::new_rc4(row.key, nullptr);
    std::vector<uint8_t> keystream;
    keystream.resize(row.keystream.size());
    crypter->encrypt(keystream, keystream);
    auto actual = encode(encoding::HEX, keystream);
    auto expected = encode(encoding::HEX, row.keystream);
    EXPECT_EQ(expected, actual);
  }
}
